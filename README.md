---
title: Advanced OS and Virtualization
author: Colin van Loo
student_id: z125018
date: 2025-07-26
---

# Advanced OS and Virtualization

## How to Compile

Ensure the Go toolchain version 1.24.3 or newer is installed.
Installation instructions are found [here](https://go.dev/doc/install).

<details>
<summary>Regenerating operation_string.go (this should not be necessary.)</summary>

The code in file `operation_string.go` is automatically generated.
If necessary, it can be regenerated by running `go generate` from the project root.

For this to work, the `stringer` command has to be installed and on the `$PATH`:

(Note that the Go toolchain usually installs into the `$HOME/go/bin` directory.)

```sh
go install golang.org/x/tools/cmd/stringer@latest
whereis stringer # $HOME/go/bin/stringer
```

`operation_string.go` provides pretty printing needed for the disassembler.
</details>

To build the project, `cd` into the project root and run:

```sh
go build
```

This will produce a file called `mmvm`.

To use a custom name, build with the `-o` option:

```sh
go build -o interpreter
```

(This will produce an ELF executable named `interpreter`.)

## How to Run

The disassembler/interpreter accepts the same arguments as the `mmvm` reference implementation: `-m` for a debug trace, `-d` for disassembly.

**Assuming the program has been compiled using `go build`, which produced an executable named `mmvm`.**

```sh
./mmvm test_programs/1.out
```

will simply interpret the program `1.out` and result in the text "hello" being written to the console.

```sh
./mmvm -m test_programs/1.out
```

will interpret the program `1.out` while showing a debug trace, similar to:

```output
 AX   BX   CX   DX   SP   BP   SI   DI  FLAGS IP
0000 0000 0000 0000 ffce 0000 0000 0000 ---- 0000:31ed         xor bp, bp
0000 0000 0000 0000 ffce 0000 0000 0000 --Z- 0002:89e3         mov bx, sp
0000 ffce 0000 0000 ffce 0000 0000 0000 --Z- 0004:8b07         mov ax, [bx] ;[ffce]0001
0001 ffce 0000 0000 ffce 0000 0000 0000 --Z- 0006:8d5702       lea dx, [bx+2] ;[ffd0]ffd8
0001 ffce 0000 ffd0 ffce 0000 0000 0000 --Z- 0009:8d4f04       lea cx, [bx+4] ;[ffd2]0000
0001 ffce ffd2 ffd0 ffce 0000 0000 0000 --Z- 000c:01c1         add cx, ax
...
```

```sh
./mmvm -d test_programs/1.out
```

will produce a disassembly of `1.out`, similar to:

```output
0000: 31ed          xor bp, bp
0002: 89e3          mov bx, sp
0004: 8b07          mov ax, [bx]
0006: 8d5702        lea dx, [bx+2]
0009: 8d4f04        lea cx, [bx+4]
000c: 01c1          add cx, ax
...
```

To run all test files at once, you may use:

```sh
for i in {1..7}; do echo "---- $i: ----"; ./mmvm "test_programs/$i.out" foo bar baz; echo; done
```

(Notice the extra arguments `foo bar baz` provided on the command line!)

```output
---- 1: ----
hello

---- 2: ----
a
---- 3: ----
hello

---- 4: ----
a=1234

---- 5: ----
argv[0]=test_programs/5.out
argv[1]=foo
argv[2]=bar
argv[3]=baz

---- 6: ----
012345
---- 7: ----
long = 4
short = 2
int = 2

```

## Code Walkthrough

### Disassembler

We define a structure similar to the one defined in Minix2's `SYS/include/a.out.h`:

```go
type Exec struct {
	MidMag struct {
		Magic   [2]byte // needs to be 0x01 0x03
		Flags   byte    // 0x20 -> separate I/D (instruction/text and data)
		CPU     byte
		HdrLen  uint8
		Unused  byte
		Version uint16
	}
	SizeText   int32
	SizeData   int32
	SizeBSS    int32
	EntryPoint int32
	MemTotal   int32
	SizeSym    int32
	/* end of short form */
}

func (e Exec) BadMag() bool {
	return e.MidMag.Magic[0] != 0x01 || e.MidMag.Magic[1] != 0x03
}
```

In the `main` function, the entire `a.out` file is read into one contiguous chunck of memory:

```go
bin := must(os.ReadFile(file))
```

<details>
<summary>must</summary>

```go
func must[T any](t T, err error) T {
	if err != nil {
		panic(err)
	}
	return t
}
```

`must` is a helper function for *very* lazy programmers who don't want to handle errors.
</details>


It is then possible to cast a pointer to this memory to the `Exec` structure:

```go
exec := *(*Exec)(unsafe.Pointer(&bin[0]))
```

The problem with this approach is that it only works if the code has been compiled for and is being run on a little-endian computer (since the data in the `a.out` file itself is layed out in little-endian order).

Instead we can make use of the `encoding/binary` package, which provides a more portable solution:

```go
var exec Exec
if err := binary.Read(bytes.NewReader(bin), binary.LittleEndian, &exec); err != nil {
	log.Fatal(err)
}
```

The `a.out` file contains (amongst other things) a *text* and a *data* section.
We can extract the *text* and the *data* parts with the help of these two functions:

```go
func (e Exec) Text(bin []byte) []byte {
	s := int32(e.MidMag.HdrLen)
	text := bin[s : s+e.SizeText]
	return text
}

func (e Exec) Data(bin []byte) []byte {
	s := int32(e.MidMag.HdrLen)
	s += e.SizeText
	data := bin[s : s+e.SizeData]
	return data
}
```

The `text` section is then passed on to the `disassemble` function for disassembling:

```go
text := exec.Text(bin)
insts, err := disassemble(text)
_ = err // we'll ignore decode errors, just emit OpInvalid
for _, inst := range insts {
	fmt.Println(InstructionFormatterWithOffset{inst})
}
```

`disassemble` returns an array (technically a `slice`, in Go terminology) of disassembled instructions.

<details>
<summary>Go slices</summary>

A slice in go is a builtin data type, that consists of a pointer to the underlaying array, a length, and a capacity.

Slices are a bit weird, in as much as that they serve two different purposes.

A slice can be used as a *view* into an array.
A slice can also be used as a dynamic array (array list), to which elements can be appended using the builtin `append` function.
As appending to a slice might cause the underlying array to be relocated, `append` returns a new slice.

A slice must only ever be used as a view, or only ever as a dynamic array.
Trying to use a slice in both ways leads to bugs!
</details>

An instruction is defined as:

```go
type Instruction struct {
	offset, size int
	bytes        [6]byte
	operation    Operation
	operands     Operands
}
```

containing information such as the offset in the program's `text` where the instruction is found, the size of the instruction (never larger than 6), the bytes which make up the instruction, as well as the operation and operands encoded by this instruction.

`Operation` is an enum:

```go
type Operation int
//go:generate stringer -type=Operation -trimprefix=Op -linecomment
const (
	OpInvalid           Operation = iota // (undefined)
	OpMovRegRm                           // mov
	OpMovRmImm                           // mov
	OpMovRegImm                          // mov
	// <omitted for brevity...>
	OpPushRm                             // push
	OpPushReg                            // push
	// <omitted for brevity...>
)
```

<details>
<summary>Enums in Go</summary>

Go doesn't really have enums.
Instead, enums are encoded as a newtype (`type MyEnum int`) and a bunch of constants.
Constants can be "initialized" using `iota`, which will simply assign numbers in increasing order.
```go
type MyEnum int
const (
	Option1 MyEnum = iota
	Option2
	Option3
)
```
</details>

<details>
<summary>Code generating using `//go:generate`</summary>

Notice the line comment starting with `//go:generate stringer`.

The `Operation` enum values are just integers.
For pretty printing, we would like to give them names.
A newtype can specify its own pretty-printing format, by implementing the `fmt.Stringer` interface.

The `fmt.Stringer` interface defines a single method `String() string`:
```go
// go doc fmt.Stringer
type Stringer interface {
	String() string
}
```

We could manually implement this method:

```go
func (op Operation) String() string {
	switch op {
	case OpInvalid:
		return "(undefined)"
	case OpMovRegRm, OpMovRmImm, OpMovRegImm:
		return "mov"
	case OpPushRm, OpPushReg:
		return "push"
	// <other cases...>
	}
}
```

Or we save ourselves all this work and let the `stringer` tool auto-generate this code for us.
When running `go generate` from the command line, the source code is searched for lines such as `//go:generate stringer`.
This will cause the `stringer` tool to be invoked.
`stringer` generates a `String() string` implementation for us.

Pay attention to the comments (such as `// mov` and `// (undefined)`):
```go
OpInvalid           Operation = iota // (undefined)
OpMovRegRm                           // mov
OpMovRmImm                           // mov
```

These comments are **significant!**
They tell `stringer` what the enum value should be formatted as.
(`OpInvalid` is converted to the string `"(undefined)"`.
`OpMovRegRm` and `OpMovRmImm` are both converted to the same string `"mov"`.)
</details>

`Operands` is simply defined as a slice of `Operand`: `type Operands []Operand`.
There are different types of operands, therefore `Operand` is an interface:

```go
type Operand interface {
	fmt.Stringer
	W() byte
}
```

The `Operand` interface requires the same pretty-printing method from `fmt.Stringer` to be implemented, as well as a `W() byte` method, returning the operands width (0 -> 1 byte width, 1 -> 2 byte width).

Different types of operands include, registers:

```go
type Register struct {
	name, width byte
}
```

...memory:

```go
type Memory struct {
	width, mod, rm, dispHigh, dispLow byte
}
```

...immediates:

```go
type Immediate struct {
	width byte
	value uint16
}
```

...and a few more special cases.

Let's have a closer look at `Register`.
A register has a name and a width, both encoded by a `byte`.
```go
type Register struct {
	name, width byte
}
```
When pretty-printing, we want human readable names for the registers.
```go
func (reg Register) String() string {
	names := []string{"al", "cl", "dl", "bl", "ah", "ch", "dh", "bh", "ax", "cx", "dx", "bx", "sp", "bp", "si", "di"}
	return names[reg.name+reg.width*8]
}
```
`names` is an array of register names.
We use the formula `reg.name + (reg.width * 8)` to index into the names-array, to read out the proper name.
For example, the register identified by the byte `0b1` corresponds to the `cl` register, unless its width is a word (2 bytes), as indicated by `reg.width == 1`, in which case we have to skip 8 entries in the name array `+ reg.width * 8` to end up at `cx`.

Pretty-printing for `Memory` operands is more involved:

```go
func (mem Memory) String() string {
	names := []string{"bx+si", "bx+di", "bp+si", "bp+di", "si", "di", "bp", "bx"}
	switch mem.mod {
	default:
		panic("invalid mod")
	case 0b00:
		if mem.rm == 0b110 {
			disp := (int16(mem.dispHigh) << 8) ^ int16(mem.dispLow)
			return fmt.Sprintf("[%04x]", disp)
		}
		return "[" + names[mem.rm] + "]"
	case 0b01:
		return fmt.Sprintf("[%s%+x]", names[mem.rm], int16(int8(mem.dispLow)))
	case 0b10:
		disp := (int16(mem.dispHigh) << 8) ^ int16(mem.dispLow)
		return fmt.Sprintf("[%s%+x]", names[mem.rm], disp)
	case 0b11:
		panic("rm is reg")
	}
}
```

Depending on the `mod`, the disposition values have to be interpreted in different ways.
This method basically encodes what is described in the "NOTES:" section on the last page of the 8086 specification:

![A screenshot from the NOTES section of the last page of the 8086 specification.](./8086_spec_notes.png)

To come back to this piece of code:
```go
text := exec.Text(bin)
insts, err := disassemble(text)
_ = err // we'll ignore decode errors, just emit OpInvalid
for _, inst := range insts {
	fmt.Println(InstructionFormatterWithOffset{inst})
}
```

The disassembled instructions are printed to the console using an `InstructionFormatterWithOffset`.
There are two different instruction formatter implemented, as we want to pretty-print them in slightly different ways, depending on whether where doing a disassembly (`-d`) or a tracing (`-m`).
There is nothing special about these formatters otherwise, they are just simple structures that wrap around an `Instruction` and implement a `String() string` method.

---

To finally get to the actually interesting part: the disassembling.

There are various helper functions defined to decode common patterns, that are shared between many instructions.

```go
func decodeImmediate(src *Source, width byte) Immediate {
	var data uint16
	if width == 1 {
		b1 := src.Next()
		b2 := src.Next()
		data = (uint16(b2) << 8) ^ uint16(b1)
	} else {
		b1 := src.Next()
		data = uint16(b1)
	}
	return Immediate{width: width, value: data}
}
```

`decodeImmediate` reads, depending on the `width`, either one or two bytes from the instruction stream and decodes them as an `Immediate`.

```go
func decodeDisposition(src *Source) Immediate {
	b1 := src.Next()
	b2 := src.Next()
	disp := (uint16(b2) << 8) ^ uint16(b1)
	dispTotal := uint16(src.Pos) + disp
	return Immediate{width: 1, value: dispTotal}
}
```

`decodeDisposition` is used for instructions encoding an address as a relative offset.
(Which is why `src.Pos`, the position in the instruction stream, is added to the decoded disposition, to obtain the effective address.)

There are a few more such helper functions, last but not least `decodeModRegRm`:

```go
func decodeModRegRm(src *Source, width byte) (oreg, orm Operand) {
	mod, reg, rm := MODREGRM(src.Next())
	oreg = Register{name: reg, width: width}
	switch mod {
	case 0b00:
		if rm == 0b110 {
			orm = Memory{width: width, mod: mod, rm: rm, dispLow: src.Next(), dispHigh: src.Next()}
		} else {
			orm = Memory{width: width, mod: mod, rm: rm}
		}
	case 0b01:
		orm = Memory{width: width, mod: mod, rm: rm, dispHigh: 0, dispLow: src.Next()}
	case 0b10:
		orm = Memory{width: width, mod: mod, rm: rm, dispLow: src.Next(), dispHigh: src.Next()}
	case 0b11:
		orm = Register{name: rm, width: width}
	}
	return oreg, orm
}
```

This too is a very common pattern used by many instructions on the 8086.
Depending on the value of `mod`, the subsequent bytes have to be decoded either as some sort of memory access or as a register.

The actual decoding is done in a function `decode`, comprising a total of 517 lines of code.

```go
func decode(src *Source) (inst Instruction, err error) {
	defer func() {
		if r := recover(); r != nil {
			// assumption: the only thing that could ever cause a panic is an array out-of-bounds access
			bs, offset, size := src.Consume()
			inst = Instruction{
				offset:    offset,
				size:      size,
				operation: OpInvalid,
				operands:  nil,
			}
			copy(inst.bytes[:], bs)
			err = errors.Join(err, errors.New("unexpected EOF"))
		}
	}()
	var (
		op  Operation
		opn Operands
	)
	switch i1 := src.Next(); {
	default:
		err = fmt.Errorf("unrecognized opcode: %02x", i1)
	case i1 == 0b11111101: // std
		op = OpStd
	case i1 == 0b11111100: // cld
		op = OpCld
	// <cases omitted for brevity...>
	case i1 == 0b11101000: // call (short) label
		disp := decodeDisposition(src)
		op = OpCallDirSeg
		opn = Operands{disp}
	// <cases omitted for brevity...>
	case (i1 & 0b11111110) == 0b11111110:
		w := W(i1)
		_, rm := decodeModRegRm(src, w)
		op = map[byte]Operation{
			0b000: OpIncRm,             // inc rm16 // inc rm8
			0b001: OpDecRm,             // dec rm16 // dec rm8
			0b010: OpCallIndirSeg,      // call (short) rm16
			0b011: OpCallIndirInterSeg, // call (far)   rm16
			0b100: OpJmpIndirSeg,       // jmp  (short) rm16
			0b101: OpJmpIndirInterSeg,  // jmp  (far)   rm16
			0b110: OpPushRm,            // push rm16
		}[REG(src.B(1))]
		opn = Operands{rm}
	// <cases omitted for brevity...>
	}
	bs, offset, size := src.Consume()
	inst = Instruction{
		offset:    offset,
		size:      size,
		operation: op,
		operands:  opn,
	}
	copy(inst.bytes[:], bs)
	return inst, err
}
```

`decode` decodes *one* instruction from the source stream.
Calling `src.Next()` simply returns the next byte in the stream.
However, in order to make the code less convoluted, `src.Next()` doesn't do any error checking.
This has the consequence, that if the instruction stream is malformed, we might try to read past the end of the stream, causing an out-of-bounds array access.

This is taken care of by the `defer` ... `recover` at the top of the `decode` function:

```go
defer func() {
	if r := recover(); r != nil {
		// assumption: the only thing that could ever cause a panic is an array out-of-bounds access
		bs, offset, size := src.Consume()
		inst = Instruction{
			offset:    offset,
			size:      size,
			operation: OpInvalid,
			operands:  nil,
		}
		copy(inst.bytes[:], bs)
		err = errors.Join(err, errors.New("unexpected EOF"))
	}
}()
```

This will catch the panic induced by the out-of-bounds read and instead emit an invalid instruction `OpInvalid` and set the error as `unexpected EOF`.

<details>
<summary>Deferred functions, named return values, and panic/recover</summary>

The `defer` keyword is used to register functions that will run *when* the current function returns.
If there are multiple deferred functions, they will be executed in opposite order in which they had been deferred. (Kind of like LIFO.)

In Go, error handling is generally done by returning an error value (any value implementing the builtin `error` interface).
Using `panic`/`recover` for error handling is very unusual, and only rarely employed.
`panic`s are normally reserved for really catastrophic, unrecoverable errors.

Still, it is possible to recover from a panic, by calling `recover()` from *inside* a deferred function.

A function in Go can assign names to return values:
```go
func decode(src *Source) (inst Instruction, err error) {
```
This function takes one argument of type `*Source` named `src`, and has two return values, one named `inst` and of type `Instruction`, another named `err` of type `error`.

When we give these return value names, we can reassign them from within a deferred function, like so:
```go
func foo(i int) (r int) {
	defer func() {
		r = 42
	}()
	return i + 1
}
foo(5) // will return 42, and *not* 6!
```

*The above `decode` function might be a bit tricky to understand for those unused to the Go programming language, as `decode` makes use of all the language features described here.*
</details>

We then decode operation type and operands for the current instruction:

```go
case i1 == 0b11101000: // call (short) label
	disp := decodeDisposition(src)
	op = OpCallDirSeg
	opn = Operands{disp}
```

...and finally construct and return the `Instruction`:

```go
bs, offset, size := src.Consume()
inst = Instruction{
	offset:    offset,
	size:      size,
	operation: op,
	operands:  opn,
}
copy(inst.bytes[:], bs)
return inst, err
```

`src.Consume()` advances the input stream past the end of the instruction we just finished decoding.

`disassemble` is the function that constructs the `Source` stream and calls `decode` in a loop, until the end of the instruction stream is reached:

```go
func disassemble(text []byte) (insts []Instruction, disasErr error) {
	src := &Source{Text: text}
	for !src.IsEnd() {
		inst, err := decode(src)
		disasErr = errors.Join(disasErr, err)
		insts = append(insts, inst)
	}
	return insts, disasErr
}
```

Disassembly does *not* stop at the first error.
We try to process the entire `text` section, and simply gather up all errors encountered.

There is a script called `make_test.sh` which can be invoked using:

```sh
./make_test.sh all ; echo $?
A=test_programs/1.out ./make_test.sh
```

This script will compare the output of my implementation against the output of professor FUKUDA Hiroaki's implementation and produce a diff.

The diff can be opened in a diff viewer, for example, Meld.

```sh
meld mine.disas other.disas
```

I used this during development to verify the correctness of my implementation.

### Interpreter

Definition of the `CPU` structure:

```go
type (
	CPU struct {
		RegisterFile [10]uint16
		Text         RAM
		Data         RAM
		ProgramBreak uint16
	}
	Runtime interface {
		Syscall(*CPU)
	}
	Flags struct {
		reg *uint16
	}
	RAM [1 << 32]byte
)
```

Entry to the interpreter is the `emulate` function:

```go
var ErrHaltAndCatchFire = errors.New("halted and on fire")

func emulate(exec Exec, name string, bin []byte, args []string, debug bool) error {
	cpu := &CPU{}
	rt := Minix{}
	cpu.RegisterFile[RegSP] = 0xFFFF
	cpu.Execve(append([]string{name}, args...), []string{"PATH=/usr:/usr/bin"})
	text := exec.Text(bin)
	data := exec.Data(bin)
	cpu.Text.WriteBytes(0, text)
	off := uint16(0)
	cpu.Data.WriteBytes(off, data); off += uint16(len(data))
	cpu.Data.WriteZeros(off, uint16(exec.SizeBSS)); off += uint16(exec.SizeBSS)
	cpu.RegisterFile[RegIP] = uint16(exec.EntryPoint)
	if debug {
		fmt.Println(" AX   BX   CX   DX   SP   BP   SI   DI  FLAGS IP")
	}
	for {
		src := cpu.Fetch()
		inst, err := cpu.Decode(src)
		if err != nil {
			return err
		}
		if debug {
			fmt.Printf("%s:%s\n", cpu, InstructionFormatterWithMemoryAccess{inst, cpu})
		}
		cpu.Step(rt, inst)
	}
	return ErrHaltAndCatchFire
}
```

This loads the text and data sections into memory, sets up the stack, and initializes registers.

In a loop, we fetch the next instruction `cpu.Fetch()`, decode it `cpu.Decode(src)`, print out some debug output if the `-m` flag was set, and execute the instruction `cpu.Step(rt, inst)`.

Setup of the stack is done by the `Execve` method:

```go
func (cpu *CPU) Execve(argv, envp []string) {
	totalLen := 3 * uint16(2) // argc, two nil pointers
	for _, s := range slices.Concat(envp, argv) {
		totalLen += uint16(len(s)) + 1
		totalLen += 2
	}
	frame := cpu.RegisterFile[RegSP]
	// padding for alignment if necessary
	if (frame-totalLen)%2 != 0 {
		frame -= 1
		cpu.Data.WriteZeros(frame, 1)
	}
	addrs := make([]uint16, len(argv)+len(envp))
	ss := slices.Concat(argv, envp)
	slices.Reverse(ss)
	for i, s := range ss {
		frame -= uint16(len(s)) + 1
		cpu.Data.WriteString(frame, s)
		addrs[i] = frame
	}
	frame -= 2; cpu.Data.Write16(frame, 0)
	for _, p := range addrs[:len(envp)] {
		frame -= 2; cpu.Data.Write16(frame, p)
	}
	frame -= 2; cpu.Data.Write16(frame, 0)
	for _, p := range addrs[len(envp):] {
		frame -= 2; cpu.Data.Write16(frame, p)
	}
	frame -= 2; cpu.Data.Write16(frame, uint16(len(argv)))
	cpu.RegisterFile[RegSP] = frame
}
```

This sets up the stack in the same way that Minix2 would do it.
The number of arguments (argc), pointers to the argument strings, pointers to the environment strings, the actual argument strings and the actual environment strings.

The `Step` method takes an instruction and executes it:

```go
func (cpu *CPU) Step(rt Runtime, inst Instruction) {
	switch inst.operation {
	default:
		fallthrough
	case OpInvalid:
		assert(false, ErrIllegalInstruction)
	case OpMovRegRm, OpMovRmImm, OpMovRegImm, OpMovAccMem, OpMovMemAcc, OpMovRmSeg:
		dst := inst.operands[0]
		src := inst.operands[1]
		switch {
		default:
			panic(ErrOperandWidthMismatch)
		case dst.W() == 0 && src.W() == 0:
			cpu.Set8(dst, cpu.Get8(src))
		case dst.W() == 1 && src.W() == 1:
			cpu.Set16(dst, cpu.Get16(src))
		}
		// FLAGS none affected
	case OpPushRm, OpPushReg, OpPushSeg:
		arg := inst.operands[0]
		cpu.RegisterFile[RegSP] -= 2
		switch arg.W() {
		case 0:
			cpu.Data.Write16(cpu.RegisterFile[RegSP], uint16(cpu.Get8(arg)))
		case 1:
			cpu.Data.Write16(cpu.RegisterFile[RegSP], uint16(cpu.Get16(arg)))
		}
		// FLAGS none affected
	case OpAdcRegRm, OpAdcRmImm, OpAdcAccImm:
		dst := inst.operands[0]
		src := inst.operands[1]
		c := int32(CF(cpu.RegisterFile[RegFLAGS]))
		switch {
		default:
			panic(ErrOperandWidthMismatch)
		case dst.W() == 0 && src.W() == 0:
			r := cpu.Get8(dst) + cpu.Get8(src) + c
			cpu.Set8(dst, r)
			cpu.Flags().SetZSCO(r == 0, r < 0, r > math.MaxUint8, r > math.MaxInt8 || r < math.MinInt8)
		case dst.W() == 1 && src.W() == 1:
			r := cpu.Get16(dst) + cpu.Get16(src) + c
			cpu.Set16(dst, r)
			cpu.Flags().SetZSCO(r == 0, r < 0, r > math.MaxUint16, r > math.MaxInt16 || r < math.MinInt16)
		case dst.W() == 1 && src.W() == 0 && isImm(src):
			r := cpu.Get16(dst) + cpu.Get8(src) + c
			cpu.Set8(dst, r)
			cpu.Flags().SetZSCO(r == 0, r < 0, r > math.MaxUint16, r > math.MaxInt16 || r < math.MinInt16)
		}
	case OpIntTypeSpecified:
		t := inst.operands[0]
		v := cpu.Get8(t)
		cpu.interrupt(v, rt)
		// FLAGS none affected
	// <other cases omitted for brevity...>
	}
	cpu.RegisterFile[RegIP] += uint16(inst.size)
}
```

This function doesn't do error handling, instead it just panics when encountering an unexpected condition.
There is good reason for this!
`Step` shouldn't ever receive anything invalid.
All parsing and validating of input is taken care of at earlier steps, e.g., in the `Fetch` and `Decode` methods.


The `Get8`, `Get16`, `Set8`, and `Set16` methods dispatch on the type of the operand and read (or write) data from (or to) the correct place.

```go
func (cpu *CPU) Get16(opnd Operand) int32 {
	switch o := opnd.(type) {
	default:
		panic(fmt.Errorf("invalid operand: %T", opnd))
	case Register:
		if o.width == 0 && o.name >= RegAH && o.name <= RegBH {
			return int32(int8(cpu.RegisterFile[o.name-RegAH] >> 8))
		}
		return int32(int16(cpu.RegisterFile[o.name]))
	case Memory:
		addr := o.Addr(cpu)
		return int32((int16(cpu.Data[addr+1]) << 8) | int16(cpu.Data[addr]))
	case Immediate:
		return int32(int16(o.value))
	case SignedImmediate:
		return int32(int16(o.value))
	}
}
```

```go
func (cpu *CPU) Set16(opnd Operand, val int32) {
	switch o := opnd.(type) {
	default:
		panic(fmt.Errorf("invalid operand: %T", opnd))
	case Register:
		if o.width == 0 && o.name >= RegAH && o.name <= RegBH {
			// @fixme: should it even be valid to call Set16 on a 8-bit reg?
			cpu.RegisterFile[o.name-RegAH] = uint16(val<<8) | (cpu.RegisterFile[o.name-RegAH] & 0x00FF)
		} else {
			cpu.RegisterFile[o.name] = uint16(val)
		}
	case Memory:
		addr := o.Addr(cpu)
		cpu.Data[addr+1] = byte(val >> 8)
		cpu.Data[addr+0] = byte(val >> 0)
	}
}
```

Note that, whether we're operating on a byte or a word (2 bytes), values are always cast to and from `int32`s.
`int32`s are used because it makes calculating the `FLAGS` register easier.

For a memory operand, the address has to be calculated based on current register values.

```go
func BaseOffset(cpu *CPU, i byte, disp int16) uint16 {
	const RegInv = RegLast + 1
	type BaseOffset struct {
		Base, Offset byte
	}
	names := []BaseOffset{
		{RegB, RegSI},
		{RegB, RegDI},
		{RegBP, RegSI},
		{RegBP, RegDI},
		{RegSI, RegInv},
		{RegDI, RegInv},
		{RegBP, RegInv},
		{RegB, RegInv},
	}
	bo := names[i]
	base := int16(cpu.RegisterFile[bo.Base])
	offset := int16(0)
	if bo.Offset <= RegLast {
		offset = int16(cpu.RegisterFile[bo.Offset])
	}
	return uint16(base + offset + disp)
}

func (mem Memory) Addr(cpu *CPU) uint16 {
	switch mem.mod {
	default:
		panic("unreachable")
	case 0b00:
		if mem.rm == 0b110 {
			return (uint16(mem.dispHigh) << 8) ^ uint16(mem.dispLow)
		}
		return BaseOffset(cpu, mem.rm, 0)
	case 0b01:
		disp := int16(int8(mem.dispLow))
		return BaseOffset(cpu, mem.rm, disp)
	case 0b10:
		disp := (int16(mem.dispHigh) << 8) ^ int16(mem.dispLow)
		return BaseOffset(cpu, mem.rm, disp)
	}
}
```

This again, just implements what is explained in this section of the 8086 specification:

![A screenshot from the NOTES section of the last page of the 8086 specification.](./8086_spec_notes.png)

Interrupts are handled by the CPU:

```go
func (cpu *CPU) interrupt(idx int32, rt Runtime) {
	vector := [256]func(*CPU){
		0x20: rt.Syscall, // syscall
	}
	f := vector[idx]
	if f != nil {
		f(cpu)
	} else {
		log.Printf("unhandled interrupt: %02x", idx)
	}
}
```

The only type of interrupt we actually implement is the syscall.
Syscalls are handled by the `Minix` runtime:

```go
type Minix struct{}

func (minix Minix) Syscall(cpu *CPU) {
	noSys := func(*CPU) uint16 {
		return uint16(EINVAL)
	}
	vector := [78]func(*CPU) uint16{
		0: noSys,
		1: func(cpu *CPU) uint16 { // exit
			type Msg struct {
				source, type_, code uint16
			}
			addr := cpu.RegisterFile[RegB]
			bs := cpu.Data[addr : addr+uint16(unsafe.Sizeof(Msg{}))]
			msg := (*Msg)(unsafe.Pointer(&bs[0]))
			if *m {
				fmt.Printf("<exit(%d)>\n", msg.code)
			}
			os.Exit(int(msg.code))
			return msg.code
		},
		// <omitted for brevity...>
		4: func(cpu *CPU) uint16 { // write
			type Msg struct {
				source, type_    uint16
				fd, len, _, addr uint16
			}
			addr := cpu.RegisterFile[RegB]
			bs := cpu.Data[addr : addr+uint16(unsafe.Sizeof(Msg{}))]
			msg := (*Msg)(unsafe.Pointer(&bs[0]))
			if *m {
				fmt.Printf("<write(%d, 0x%04x, %d)", msg.fd, msg.addr, msg.len)
			}
			str := string(cpu.Data[msg.addr : msg.addr+msg.len])
			fmt.Print(str)
			ret := len(str)
			if *m {
				fmt.Printf(" => %d>\n", ret)
			}
			cpu.RegisterFile[RegA] = 0 // ?
			return uint16(ret)
		},
		// <omitted for brevity...>
		17: func(cpu *CPU) uint16 { // break
			type Msg struct {
				source, type_ uint16
				_             [6]byte
				address       uint16
				_             [6]byte
				reply         uint16
			}
			addr := cpu.RegisterFile[RegB]
			bs := cpu.Data[addr : addr+uint16(unsafe.Sizeof(Msg{}))]
			msg := (*Msg)(unsafe.Pointer(&bs[0]))
			if *m {
				fmt.Printf("<brk(0x%04x) => ", msg.address)
			}
			ret := uint16(0)
			if true { // @todo: checks???
				cpu.ProgramBreak = msg.address
				msg.reply = cpu.ProgramBreak
				if *m {
					fmt.Printf("0>\n")
				}
			} else {
				ret = uint16(-ENOMEM)
				msg.reply = 0xFFFF // -1
				if *m {
					fmt.Printf("ENOMEM>\n")
				}
			}
			cpu.RegisterFile[RegA] = 0 // ?
			return ret
		},
		// <omitted for brevity...>
		54: func(cpu *CPU) uint16 { // ioctl
			type Msg struct {
				source  uint16
				type_   uint16
				fd      uint16
				_       [2]byte
				request uint16
				_       [8]byte
				address uint16
			}
			addr := cpu.RegisterFile[RegB]
			bs := cpu.Data[addr : addr+uint16(unsafe.Sizeof(Msg{}))]
			msg := (*Msg)(unsafe.Pointer(&bs[0]))
			if *m {
				fmt.Printf("<ioctl(%d, 0x%04x, 0x%04x)>\n", msg.fd, msg.request, msg.address)
			}
			cpu.RegisterFile[RegA] = 0 // ?
			return uint16(-EINVAL)
		},
		// <omitted for brevity...>
	}
	type Msg struct {
		source, type_ uint16
	}
	addr := cpu.RegisterFile[RegB]
	bs := cpu.Data[addr : addr+uint16(unsafe.Sizeof(Msg{}))]
	msg := (*Msg)(unsafe.Pointer(&bs[0]))
	ret := vector[msg.type_](cpu)
	msg.type_ = ret
}
```

Again, most syscalls are unimplemented.
We only care about `exit`, `write`, and a stubbed out `break` and `ioctl`.

We define `Msg` structures "on the fly" to cast memory and read out the arguments passed to the syscall.
Padding within a messega struct is just filled in with `_ [N]byte` for `N` byte padding.

Syscalls set the AX register to 0, as it seems that is what the reference implementation also does.

Output of the interpreter can be diffed against the output of professor FUKUDA Hiroaki's reference implementation:

```sh
MODE=-m ./make_test.sh all ; echo $?
A=test_programs/1.out MODE=-m ./make_test.sh
A=test_programs/1.out MODE=-m LIMIT=200 ./make_test.sh

meld mine.disas other.disas # open in diff viewer
```
